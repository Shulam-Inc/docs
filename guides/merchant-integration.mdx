---
title: "Merchant Integration"
description: "Complete server-side guide for accepting Shulam payments"
---

# Merchant Integration

This guide covers the full server-side integration for accepting USDC payments via Shulam.

## Integration Flow

```
1. Buyer requests a paid resource from your server
2. Your server returns HTTP 402 with payment requirements
3. The buyer's client signs an EIP-3009 authorization and retries with X-PAYMENT header
4. Your middleware verifies + settles the payment automatically
5. Your route handler runs with req.payment containing the settlement details
6. You receive a webhook confirming the payment
```

## Quick Setup with SDK Middleware

The fastest way to add payments — three lines with `requirePayment()`:

```typescript
import express from "express";
import { requirePayment } from "@shulam/sdk/express";

const app = express();
app.use(express.json());

// Any route becomes a paywall
app.get(
  "/api/premium",
  requirePayment({ amount: "10000000", payTo: process.env.MERCHANT_WALLET }),
  (req, res) => {
    // req.payment is populated after successful verification + settlement
    res.json({
      data: "premium content",
      paidBy: req.payment.payer,
      txHash: req.payment.txHash,
      settled: req.payment.settled,
    });
  }
);
```

The middleware handles the full x402 flow: returns 402 when no payment header is present, verifies the signature, settles on-chain, and attaches the result to `req.payment`.

## Multi-Endpoint Configuration

For apps with multiple paid endpoints at different price points, use `createShulamServer`:

```typescript
import { createShulamServer } from "@shulam/x402/server";

const shulam = createShulamServer({
  facilitatorUrl: "https://api.shulam.io",
  sellerAddress: process.env.MERCHANT_WALLET,
  endpoints: {
    "/api/basic": { amount: "1000000" },    // 1 USDC
    "/api/premium": { amount: "10000000" }, // 10 USDC
    "/api/bulk": { amount: "50000000" },    // 50 USDC
  },
});
```

## Manual Integration

If you need full control over the verification and settlement flow:

```typescript
app.post("/checkout", async (req, res) => {
  const { paymentHeader, orderId } = req.body;

  // Step 1: Verify the payment signature
  const verifyRes = await fetch(`${process.env.SHULAM_API}/verify`, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${process.env.SHULAM_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      paymentHeader,
      expectedTo: process.env.MERCHANT_WALLET,
      expectedValue: getOrderAmount(orderId),
    }),
  });

  const verification = await verifyRes.json();
  if (!verification.verified) {
    return res.status(400).json({ error: verification.error });
  }

  // Step 2: Settle the payment
  const settleRes = await fetch(`${process.env.SHULAM_API}/settle`, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${process.env.SHULAM_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ paymentHeader, mode: "direct" }),
  });

  const settlement = await settleRes.json();
  if (!settlement.settled) {
    return res.status(400).json({ error: settlement.error });
  }

  await markOrderPaid(orderId, settlement.txHash);

  res.json({
    success: true,
    txHash: settlement.txHash,
    txLink: settlement.txLink,
  });
});
```

## Handling Webhooks

Don't rely solely on the settlement response — use webhooks for reliable payment confirmation:

```javascript
import crypto from "node:crypto";

app.post("/webhooks/shulam", (req, res) => {
  // Verify webhook signature
  const signature = req.headers["x-shulam-signature"];
  const payload = JSON.stringify(req.body);
  const expected = crypto
    .createHmac("sha256", process.env.SHULAM_WEBHOOK_SECRET)
    .update(payload)
    .digest("hex");

  if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected))) {
    return res.status(401).json({ error: "Invalid signature" });
  }

  const { type, data } = req.body;

  switch (type) {
    case "payment.completed":
      fulfillOrder(data.txHash);
      break;
    case "payment.failed":
      notifyCustomer(data.error);
      break;
    case "escrow.released":
      markOrderShipped(data.escrowId);
      break;
  }

  res.json({ received: true });
});
```

## Error Handling

Always handle settlement failures gracefully:

```javascript
if (!settlement.settled) {
  if (settlement.retryable) {
    // Queue for retry with exponential backoff
    await retryQueue.add("settle-payment", {
      paymentHeader,
      orderId,
      attempt: 1,
    });
    return res.json({ status: "pending", message: "Payment is being processed" });
  } else {
    // Permanent failure — ask buyer to try again
    return res.status(400).json({
      error: "Payment failed. Please try again with a new authorization.",
    });
  }
}
```

## Idempotency

Payment authorizations are naturally idempotent — each nonce can only be used once. If you accidentally call `/settle` twice with the same authorization, the second call will fail with `nonce already used`.

## Going Live Checklist

- [ ] Swap `sk_test_` for `sk_live_` API key
- [ ] Update merchant wallet to Base Mainnet address
- [ ] Configure production webhook endpoint with HTTPS
- [ ] Test with a small real payment (e.g., $1 USDC)
- [ ] Set up monitoring for failed webhooks
- [ ] Implement retry logic for transient failures
